/**
 * Expectation Registry
 * Singleton registry for all expectations with cross-context validation
 * @module @bhumika/bhasha/decorators/expectation
 */

import type { ExpectationMetadata } from '../../types/decorator-metadata.types.js';
import { BoundedContextRegistry } from '../domain/registries.js';
import { StakeholderRegistry } from '../stakeholder/registries.js';
import { TestRegistry } from '../test/test.registry.js';

/**
 * Type alias for class constructors
 */
type Constructor = new (...args: never[]) => unknown;

/**
 * Registry entry containing both metadata and constructor
 */
interface ExpectationRegistryEntry {
  metadata: ExpectationMetadata;
  constructor?: Constructor;
}

/**
 * Cross-context validation result
 */
export interface CrossContextValidationResult {
  /**
   * Is the cross-context relationship valid?
   */
  valid: boolean;

  /**
   * Relationship type if valid (same-context, upstream, downstream, partnership, etc.)
   */
  relationship?: string;

  /**
   * Warning message if relationship is unusual but allowed
   */
  warning?: string;

  /**
   * Error message if validation failed
   */
  error?: string;
}

/**
 * ExpectationRegistry - Singleton registry for all expectations
 *
 * Provides:
 * - Registration and lookup by ID, stakeholder, journey, milestone
 * - Cross-context expectation tracking
 * - Critical: Cross-context relationship validation
 *
 * @example
 * ```typescript
 * const registry = ExpectationRegistry.getInstance();
 *
 * // Get expectation by ID
 * const exp = registry.getById('deposit-money-EXP-001');
 *
 * // Get all expectations for a stakeholder
 * const expectations = registry.getByStakeholder('Account Owner');
 *
 * // Get cross-context expectations
 * const crossContext = registry.getCrossContext();
 *
 * // Validate cross-context relationship
 * const validation = registry.validateContextRelationship(expectation);
 * ```
 */
export class ExpectationRegistry {
  private static instance: ExpectationRegistry;

  /**
   * Map of expectation ID -> registry entry
   */
  private readonly expectationsById = new Map<
    string,
    ExpectationRegistryEntry
  >();

  /**
   * Map of stakeholder name -> array of expectation IDs
   */
  private readonly expectationsByStakeholder = new Map<string, string[]>();

  /**
   * Map of journey slug -> array of expectation IDs
   */
  private readonly expectationsByJourney = new Map<string, string[]>();

  /**
   * Map of milestone ID -> array of expectation IDs
   */
  private readonly expectationsByMilestone = new Map<string, string[]>();

  private constructor() {
    // Private constructor for singleton
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): ExpectationRegistry {
    if (!ExpectationRegistry.instance) {
      ExpectationRegistry.instance = new ExpectationRegistry();
    }
    return ExpectationRegistry.instance;
  }

  /**
   * Register expectation in the registry
   * Called automatically by @Expectation decorator
   *
   * @param expectation - Expectation metadata
   * @param constructor - Optional expectation class constructor
   * @throws Error if expectation with same ID already exists
   */
  public register(
    expectation: ExpectationMetadata,
    constructor?: Constructor
  ): void {
    const { expectingStakeholder, providingStakeholder } = expectation;

    // Ensure expectationId is present
    if (!expectation.expectationId) {
      throw new Error(
        `@Expectation: expectationId is required but was not provided. ` +
          `This should be auto-generated by the @Expectation decorator.`
      );
    }

    const expectationId = expectation.expectationId;

    // Check for duplicates
    if (this.expectationsById.has(expectationId)) {
      throw new Error(
        `@Expectation "${expectationId}": Expectation with this ID already exists. ` +
          `Expectation IDs must be unique.`
      );
    }

    // Store in main registry
    this.expectationsById.set(expectationId, {
      metadata: expectation,
      constructor,
    });

    // Index by expecting stakeholder
    const expectingIndex =
      this.expectationsByStakeholder.get(expectingStakeholder) || [];
    expectingIndex.push(expectationId);
    this.expectationsByStakeholder.set(expectingStakeholder, expectingIndex);

    // Index by providing stakeholder
    const providingIndex =
      this.expectationsByStakeholder.get(providingStakeholder) || [];
    providingIndex.push(expectationId);
    this.expectationsByStakeholder.set(providingStakeholder, providingIndex);

    // Index by journey (if provided)
    if (expectation.journeySlug && typeof expectation.journeySlug === 'string') {
      const journeyIndex =
        this.expectationsByJourney.get(expectation.journeySlug) || [];
      journeyIndex.push(expectationId);
      this.expectationsByJourney.set(expectation.journeySlug, journeyIndex);
    }

    // Index by milestone (if provided)
    if (expectation.milestoneId && typeof expectation.milestoneId === 'string') {
      const milestoneIndex =
        this.expectationsByMilestone.get(expectation.milestoneId) || [];
      milestoneIndex.push(expectationId);
      this.expectationsByMilestone.set(expectation.milestoneId, milestoneIndex);
    }
  }

  /**
   * Get expectation by ID
   * @param expectationId - Expectation ID
   * @returns Registry entry or undefined
   */
  public getById(expectationId: string): ExpectationRegistryEntry | undefined {
    return this.expectationsById.get(expectationId);
  }

  /**
   * Get all expectations involving a stakeholder (as expecting or providing)
   * @param stakeholder - Stakeholder name
   * @returns Array of expectation entries
   */
  public getByStakeholder(stakeholder: string): ExpectationRegistryEntry[] {
    const ids = this.expectationsByStakeholder.get(stakeholder) || [];
    return ids
      .map((id) => this.expectationsById.get(id))
      .filter(
        (entry): entry is ExpectationRegistryEntry => entry !== undefined
      );
  }

  /**
   * Get all expectations in a journey
   * @param journeySlug - Journey slug
   * @returns Array of expectation entries
   */
  public getByJourney(journeySlug: string): ExpectationRegistryEntry[] {
    const ids = this.expectationsByJourney.get(journeySlug) || [];
    return ids
      .map((id) => this.expectationsById.get(id))
      .filter(
        (entry): entry is ExpectationRegistryEntry => entry !== undefined
      );
  }

  /**
   * Get all expectations for a milestone
   * @param milestoneId - Milestone ID
   * @returns Array of expectation entries
   */
  public getByMilestone(milestoneId: string): ExpectationRegistryEntry[] {
    const ids = this.expectationsByMilestone.get(milestoneId) || [];
    return ids
      .map((id) => this.expectationsById.get(id))
      .filter(
        (entry): entry is ExpectationRegistryEntry => entry !== undefined
      );
  }

  /**
   * Get all cross-context expectations
   * (where expecting and providing stakeholders are in different contexts)
   * @returns Array of cross-context expectation entries
   */
  public getCrossContext(): ExpectationRegistryEntry[] {
    const allExpectations = Array.from(this.expectationsById.values());

    return allExpectations.filter((entry) => {
      const { expectingStakeholder, providingStakeholder } = entry.metadata;

      // Get contexts for both stakeholders
      const expectingEntry = StakeholderRegistry.get(expectingStakeholder);
      const providingEntry = StakeholderRegistry.get(providingStakeholder);

      if (!expectingEntry || !providingEntry) {
        return false; // Skip if stakeholders not registered
      }

      const expectingContext = expectingEntry.metadata.context;
      const providingContext = providingEntry.metadata.context;

      // Check if contexts are different
      return expectingContext !== providingContext;
    });
  }

  /**
   * Get expectations between two specific contexts
   * @param contextA - First context name
   * @param contextB - Second context name
   * @returns Array of expectation entries between these contexts
   */
  public getBetweenContexts(
    contextA: string,
    contextB: string
  ): ExpectationRegistryEntry[] {
    const allExpectations = Array.from(this.expectationsById.values());

    return allExpectations.filter((entry) => {
      const { expectingStakeholder, providingStakeholder } = entry.metadata;

      // Get contexts for both stakeholders
      const expectingEntry = StakeholderRegistry.get(expectingStakeholder);
      const providingEntry = StakeholderRegistry.get(providingStakeholder);

      if (!expectingEntry || !providingEntry) {
        return false;
      }

      const expectingContext = expectingEntry.metadata.context;
      const providingContext = providingEntry.metadata.context;

      // Check if contexts match (in either direction)
      return (
        (expectingContext === contextA && providingContext === contextB) ||
        (expectingContext === contextB && providingContext === contextA)
      );
    });
  }

  /**
   * Validate cross-context relationship for an expectation
   * CRITICAL: Validates if cross-context expectation is allowed based on bounded context relationships
   *
   * @param expectation - Expectation metadata to validate
   * @returns Validation result with status and details
   */
  public validateContextRelationship(
    expectation: ExpectationMetadata
  ): CrossContextValidationResult {
    const { expectingStakeholder, providingStakeholder } = expectation;

    // Get stakeholder entries
    const expectingEntry = StakeholderRegistry.get(expectingStakeholder);
    const providingEntry = StakeholderRegistry.get(providingStakeholder);

    // If stakeholders not registered, return warning
    if (!expectingEntry || !providingEntry) {
      return {
        valid: true, // Allow but warn
        warning:
          `One or both stakeholders not registered. ` +
          `Expecting: "${expectingStakeholder}", Providing: "${providingStakeholder}". ` +
          `Make sure stakeholders are decorated and imported.`,
      };
    }

    const expectingContext = expectingEntry.metadata.context;
    const providingContext = providingEntry.metadata.context;

    // Same context - always valid
    if (expectingContext === providingContext) {
      return {
        valid: true,
        relationship: 'same-context',
      };
    }

    // Different contexts - check bounded context relationships
    const expectingContextEntry = BoundedContextRegistry.get(expectingContext);

    // If bounded context not registered, return warning
    if (!expectingContextEntry) {
      return {
        valid: true, // Allow but warn
        warning:
          `Cross-context expectation: "${expectingContext}" -> "${providingContext}". ` +
          `Expecting context "${expectingContext}" is not registered. ` +
          `Consider decorating it with @BoundedContext to define relationships.`,
      };
    }

    // Check if there's a defined relationship
    const relationships = expectingContextEntry.metadata.relationships || {};
    const relationshipType = relationships[providingContext];

    if (relationshipType) {
      return {
        valid: true,
        relationship: relationshipType,
      };
    }

    // No defined relationship - return warning
    return {
      valid: true, // Allow but warn
      warning:
        `Cross-context expectation without defined relationship: ` +
        `"${expectingContext}" -> "${providingContext}". ` +
        `Consider adding relationship in @BoundedContext metadata.`,
    };
  }

  /**
   * Get all registered expectations
   * @returns Array of all expectation entries
   */
  public getAll(): ExpectationRegistryEntry[] {
    return Array.from(this.expectationsById.values());
  }

  /**
   * Get all journey slugs that have expectations
   * @returns Array of journey slugs
   */
  public getAllJourneySlugs(): string[] {
    return Array.from(this.expectationsByJourney.keys());
  }

  /**
   * Get all stakeholders involved in expectations
   * @returns Array of stakeholder names
   */
  public getAllStakeholders(): string[] {
    return Array.from(this.expectationsByStakeholder.keys());
  }

  /**
   * Get expectations where ALL behaviors have tests
   * An expectation is fully tested if:
   * 1. It has at least one behavior
   * 2. ALL of its behaviors have at least one test
   * @returns Array of fully tested expectation entries
   */
  public getFullyTested(): ExpectationRegistryEntry[] {
    const allExpectations = Array.from(this.expectationsById.values());
    const testRegistry = TestRegistry.getInstance();

    return allExpectations.filter((entry) => {
      const behaviors = entry.metadata.behaviors;

      // No behaviors = not fully tested
      if (!behaviors || behaviors.length === 0) {
        return false;
      }

      // Check if ALL behaviors have tests
      return behaviors.every((behaviorName) => {
        const behaviorTests = testRegistry.getByBehavior(behaviorName);
        return behaviorTests.length > 0;
      });
    });
  }

  /**
   * Clear all registered expectations (useful for testing)
   */
  public clear(): void {
    this.expectationsById.clear();
    this.expectationsByStakeholder.clear();
    this.expectationsByJourney.clear();
    this.expectationsByMilestone.clear();
  }

  /**
   * Get registry statistics
   * @returns Statistics about registered expectations
   */
  public getStats(): {
    totalExpectations: number;
    crossContextExpectations: number;
    fullyTestedExpectations: number;
    byJourney: Record<string, number>;
    byMilestone: Record<string, number>;
    byStakeholder: Record<string, number>;
  } {
    const byJourney: Record<string, number> = {};
    for (const [journey, ids] of this.expectationsByJourney.entries()) {
      byJourney[journey] = ids.length;
    }

    const byMilestone: Record<string, number> = {};
    for (const [milestone, ids] of this.expectationsByMilestone.entries()) {
      byMilestone[milestone] = ids.length;
    }

    const byStakeholder: Record<string, number> = {};
    for (const [stakeholder, ids] of this.expectationsByStakeholder.entries()) {
      byStakeholder[stakeholder] = ids.length;
    }

    return {
      totalExpectations: this.expectationsById.size,
      crossContextExpectations: this.getCrossContext().length,
      fullyTestedExpectations: this.getFullyTested().length,
      byJourney,
      byMilestone,
      byStakeholder,
    };
  }
}
